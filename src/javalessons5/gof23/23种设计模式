gof23种设计模式group of four
	创建型模式：单例模式、工厂模式、抽象工厂模式、建造模式、原型模式
	结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
	行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式
	
1. 单例模式
	核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
	常见应用场景：任务管理器，回收站，项目中读取配置文件的类，网站计数器，应用的日志，数据库连接池，文件系统，Application，
	spring中的每个bean，sevlet，spring mvc框架中的控制器
	
	优点：只生成1个实例，减少系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，可以在程序启动时直接产生一个单例对象，
	然后永久驻留内存中
	单例模式可以在系统设置全局访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理
	
	常见的五种单例模式的实现方式：
	主要：
		饿汉式：线程安全，调用效率高。但是，不能延迟加载。
		懒汉式：线程安全，调用效率不高。但是，可以延迟加载。
	其他：
		双重检测锁式：由于jvm底层内部模型原因，偶尔会出现问题。不建议使用。
		静态内部类式：线程安全，调用效率高，可以延迟加载。
		枚举单例：线程安全，调用效率高，不能延迟加载。

2. 静态内部类模式
	懒加载
	要点： 类加载时时天然线程安全的
	1 外部类没有static属性，则不会像饿汉式那样立即加载对象。
	2 只有真正调用getInstance()， 才会加载静态内部类。加载类时时线程安全的。instance是static final类型，
	保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性。
	3 兼备了并发高效调用和延迟加载的优势
	
3. 枚举实现单例模式
	1 优点：实现简单
		 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过翻身和反序列化的漏洞！
	2 缺点：无延迟加载
	
4. UML类图
	rational rose， metamill等软件
5.常见5种单例模式的实现方式
	主要：
		饿汉式：（线程安全，调用效率高。不能延迟加载）。
		懒汉式：（线程安全，调用效率不高。可以延迟加载）。
	其他：
		双重检测锁式：（由于JVM底层内部模型原因，偶尔出现问题。不建议使用）。
		静态内部类式：（线程安全，调用效率高，可以延迟加载）。
		枚举式：（线程安全，调用效率高，天然防止反射和反序列化漏洞。不能延迟加载）。
		
	如何选用？
	若占用资源少，不需要延迟加载：枚举 好于 饿汉式
	若占用资源多，需要延迟加载：静态内部类式 好于 懒汉式

6. 工厂模式
	实现了创建者和调用者的分离
	详细分类：简单工厂模式、工厂方法模式、抽象工厂模式
	面对对象设计的基本原则：
	OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。
	DIP（依赖倒转原则 ，Dependence Inversion Principle）：要针对接口变成，不要针对实现编程。
	LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。
	
	1 简单工厂模式：
		要点：简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例。
		           对于增加新产品无能为力！不修改代码是无法扩展的
	2 工厂方法模式：
		简单工厂和工厂方法对比：
			结构复杂度：简单工厂优于工厂方法。
			代码复杂度：简单工厂优于工厂方法。
			客户端编程复杂度：简单工厂不需要实例化。
			管理上的难度：工厂方法扩展方便。
		
			更具设计理论建议：工厂方法模式更好；但实际应用中，都使用简单工厂模式。
	3 抽象工厂模式：
		用来生产不同产品族的全部产品。（对于增加新的产品无能为力；但支持增加产品族）
		抽象工厂模式是工厂方法模式的升级版本，在多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象时一种非常好的解决方式

7 建造者模式： 
	场景：
		我们需要建造一个复杂的产品。这种复杂产品的创建，有一个问题需要处理：步骤问题。
		实际开发中，我们所需要的对象构建时，也非常复杂，有很多步骤需要处理。
	建造模式本质：
		分离了对象子组件的单独构造（Builder负责）和装配（Director负责）。从而可以构造出复杂的对象。
		这个模式适用于：某个对象的构建过程复杂的情况下使用。
		由于实现了构建和装配的解耦，不同的构建器，相同的装配，也可以做出不同的对象；
		相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
8 原型模式 prototype
	场景：javascript中，继承的实现也有prototype
	原型模式：--通过new产生的一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
		--就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点
		--优势：效率高（直接克隆，避免了重新执行构造过程步骤）。
	原型模式的实现：
		--Cloneable接口和clone()方法
		--Prototype模式中实现起来最困难的地方就是复制操作，所幸java提供了clone()方法替我们做了绝大部分的事情。
	使用场景：通过new产生对象很耗时间，非常繁琐的准备数据权限或访问权限时，使用原型模式。
		原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供个调用者。
		spring中bean的创建实际就是两种：单例模式和原型模式。（原型模式需要和工厂模式搭配起来）
		
**创建型模式的总结
	单例模式（常用）：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
	工厂模式
		简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
		工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）
		抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
	建造者模式：分离对象子组件的单独构造（由Builder负责）和装配（由Director负责）。从而可以构造出复杂的对象。
	原型模式：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
8 结构型模式：
	核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类的结构，用来解决更大的问题。
	分类：
		适配器模式、代理模式、桥接模式、装饰模式、组合模式、外观模式、享元模式

9 适配器模式：
	工作中的场景
		-经常用来做旧系统改造和升级
		-如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但不幸的是，事实却是维护一个系统的代价
			往往是开发一个系统的数倍。
	见过的场景
		-java.io.InputStreamReader(InputStream)
		-java.io.OutputStreamWriter(OutputStream)
	
10 代理模式（Proxy pattern）
	核心作用：
		-通过代理，控制对对象的访问！
			可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即AOP的微观实现！）
		-AOP（Aspect Oriented Programming面向切面编程）的核心实现机制！
	核心角色：
		-抽象角色：定义代理角色和真是角色的公共对外方法
		-真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
			关注真正的业务逻辑！
		-代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
			将统一的流程控制放到代理角色中处理！
	应用场景：
		-安全代理：屏蔽对真实角色的直接访问。
		-远程代理：通过代理类处理远程方法的调用（RMI）
		-延迟加载：先加载轻量级的代理对象，真正需要时再加载真实对象
	分类：静态代理（静态定义代理类）
		动态代理（动态生成代理类）--很常用
			-JDK自带的动态代理
			-javaassist字节码操作库实现
			-CGLIB
			-ASM（底层使用指令，可维护性较差）
			动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，
				这样，我们可以更加灵活和统一的处理众多的方法。
		
		JDK自带的动态代理
			-java.lang.reflect.Proxy
				作用：动态生成代理类和对象
			-java.lang.reflect.InvocationHandler(处理器接口)
				可以通过invoke方法实现对真实角色的代理访问。
				每次通过Proxy生成代理类对象时，都要指定对应的处理器对象
				
	开发框架中的应用场景：
		-struts2中拦截器的实现
		-数据库连接池关闭处理
		-Hebernate中延迟加载的实现
		-mybatis中拦截器的实现
		-AspectJ的实现
		-spring中AOP的实现
			@日志拦截
			@声明式事务处理
		-web service
		-RMI远程方法调用
		-。。。。。。
		--实际上，随便选择一个技术框架都会用到代理模式！！！！
		
11 桥接模式
	场景：商城系统中常见的商品分类，以电脑为例，如何良好的处理商品分类销售的问题？
		可以用多层继承结构
		
	问题：
		-扩展性问题（类个数膨胀问题）
			如果要增加一个新的电脑类型：只能手机，则要增加各个品牌下面的类。
			如果要增加一个新的品牌，也要增加各种电脑类型的类。
		-违反单一职责原则：
			一个类：联想笔记本，有两个引起这个类变化的原因
	桥接模式核心要点：处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，
				使各个维度可以独立的扩展在抽象成建立关联
	桥接模式总结：
		-桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。
			桥接模式可以极大的减少之类的个数，从而降低管理和维护的成本。
		-桥接模式极大的提高了系统的可扩展性，在两个变化的维度中任意扩展一个维度，都不需要修改原有的系统，
			符合开闭原则。
	桥接模式实际开发中应用场景：
		JDBC驱动程序
		AWT中的Peer架构
		银行日志管理
			格式分类：操作日志，交易日志，异常日志
			距离分类：本地记录日志，异地记录日志
		人力资源系统中的奖金计算模块：
			奖金分类：个人奖金，团体奖金，激励奖金。
			部门分类：人事部门，销售部门，研发部门。
		OA系统中的消息处理：
			业务类型：普通消息，加急消息，特急消息
			发送方式：系统内消息，手机短信，邮件
			
12 组合模式（composite）
	使用组合模式的场景：
		把部分和整体的关系用树形结构来表示，虫儿飞时客户端可以使用统一的方式处理部分对象和整体对象。
	组合模式核心：
		-抽象构件（Component）角色：定义了叶子和容器构件的共同点
		-叶子（Leaf）构件角色：无子节点
		-容器（Composite）构件角色：有容器特征，可以包含子节点
		
	组合模式工作流程分析：
		-组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户
			在使用时可以一致性的对待容器和叶子。
		-当容器对象的指定方法被调用时， 将遍历整个树形结构，寻找包含这个方法的成员，并调用执行。
			其中，使用了递归调用的机制对整个结构进行处理。
	开发中的应用场景：
		-操作系统的资源管理器
		-GUI中的容器层次图
		-XML文件解析
		-OA系统中，组织结构的处理
		-Junit单元测试框架
			底层设计就是典型的组合模式，TestCase（叶子），TestUnite（容器），Test接口（抽象）
13 装饰模式（decorator）
	职责：
		-动态的为一个对象增加新的功能。
		-装饰模式是一种用于替代继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系
			代替继承关系，更加灵活，同时避免类型体系的快速膨胀。
			
	实现细节：
		-Component抽象构件角色：
			真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。
		-ConcreteComponent具体构件角色（真实对象）：
			io流中的FileInputStream，FileOutputStream
		-Decorator装饰角色：
			持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。
			这样，就能在真实对象调用前后增加新的功能。
		-ConcreteDecorator具体装饰角色：
			负责给构件对象增加新的责任。
	开发中使用的场景：
		-IO中输入流和输出流的设计
		-Swing包中图形界面构件功能
		-Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，
			HttpServletRequestWrapper类增强了request对象的功能。
		-Struts2中，request，response，session对象的处理
	装饰模式总结：
		-装饰模式（Decorator）也叫包装器模式（Wrapper）
		-装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，
			以便增加新的具体构件类和装饰类。
		优点：
			-扩展对象功能，比继承灵活，不会导致类个数的急剧增加
			-可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更强大的对象
			-具体构建类和装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰类。
		缺点：
			-产生很多小对象。大量小对象占据内存，一定程度上影响性能。
			-装饰模式易于出错，调试排查比较麻烦。
	装饰模式和桥接模式的区别：
		-两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。
			桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。
			装饰模式是为了增加新的功能。	
14 外观模式
	迪米特法则（最少知识原则）
		-一个软件实体应当尽可能少的与其他实体发生相互作用
	外观模式核心：
		-为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。
	开发中常见的场景
		-频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如：
			JDBC封装后的，commons提供的DBUtils类，Hibernate提供的工具类，
			spring JDBC工具类等
15 享元模式（FlyWeight）
	场景：内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。
	核心：
		-享元模式以共享的方式高效的支持大量细粒度对象的重用。
		-享元对象能做到共享的关键是区分了内部状态和外部状态。
			内部状态：可以共享，不会随环境变化而改变
			外部状态：不可以共享，会随环境变化而改变
			
	享元模式的实现：
		-FlyWeightFactory享元工厂类：创建并管理享元对象，享元池一般设计成键值对。
		-FlyWeight抽象享元类：通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
		-ConcreteFlyWeight具体享元类：为内部状态提供成员变量进行存储。
		-UnsharedConcreteFlyWeight非共享享元类：不能被共享的子类可以设计为非共享享元类。	
		
	享元模式开发中应用的场景：
		-享元模式由于其共享的特性，可以在任何“池”中操作，比如：线程池、数据连接池。
		-String类的设计也是享元模式。
	
	优点：
		-极大减少内存中对象的数量
		-相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
		-外部状态相对独立，不影响内部状态
	缺点：
		-模式较复杂，使程序逻辑复杂化
		-为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。

----行为型模式
	创建型模式：关注对象的创建过程
	结构型模式：关注对象和类的组织
	行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责，共有11种模式
	
	行为模式汇总：责任链模式，-命令模式-，-解释器模式-，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，
		模板方法模式，-访问者模式-
		
16 责任链模式
	定义：将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象诸葛判断是否有能力处理该请求，如果能则处理，
		如果不能则传递给链上的下一个对象。
	场景：
		-打牌时，轮流出牌
		-接力赛跑
		-大学中，奖学金审批
		-公司中，公文审批
	
		替代if else，方便扩展
	-链表方式定义责任链（实现的请假案例）
	-非链表方式实现的责任链
		通过集合、数组生成责任链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后
		由外部单位追加的，所以使用链表方式定义COR链就很困难。
	开发中常见的场景：
		-java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch
		-javascript中，事件的冒泡和捕获机制。java中，事件的处理采用观察者模式。
		-servlet开发中，过滤器的链式处理
		-struts2中，拦截器调用也是典型的责任链模式
	
17 迭代器模式
	场景：
		-提供一种可以遍历聚合对象的方式。又称为：游标cursor模式
		-聚合对象：存储数据
		-迭代器：遍历数据
	基本案例：
		-实现正向遍历的迭代器
		-实现逆向遍历的迭代器
18 中介者模式Mediator
	场景：
		-假如没有总经理，下面三个部门：财务部，市场部，研发部。每个部分互相打交道，关系混乱。
	核心：
		-如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂，这些对象称为“同事对象”
		-我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为如下的星型结构，每个对象都只服从中介者对象
	中介者模式的本质：
		-解耦对个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理
			这些交互关系
	开发中常见的场景：
		-MVC模式中的C，控制器就是一个中介者对象。M和V都和他打交道。
		-窗口游戏程序，窗口软件开发中的窗口对象也是一个中介者对象。
		-图形界面开发GUI中，对个组件之间的交互，可以通过引入一个中介者对象来解决，可以死整体的窗口对象或者DOM对象
		-java.lang.reflect.method#invoke()
19 命令模式command
	-命令模式：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，
		以及支持可撤销的操作。也称之为：动作Action模式、事务transaction模式。
	结构：
		-Command抽象命令类
		-ConcreteCommand具体命令类
		-Invoker调用者/请求者
			请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。
			在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。
		-Receiver接收者
			接收者执行与请求相关的操作，具体实现对请求的业务处理。
			未抽象前，实际执行操作内容的对象。
		-Client客户类
			在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，
			都通过命令对象间接调用
	开发中常见的场景：
		-Struts2中，action的整个调用过程中就有命令模式
		-数据库事务机制的底层实现
		-命令的撤销和恢复
		
		
	















